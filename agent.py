"""
AI Email Agent - 100% FREE
Uses Gmail SMTP (App Password) - No Google Cloud, No Credit Card
Detects job roles, sends correct resume, CC correct person
"""

import os
import json
import base64
import logging
import re
import smtplib
from pathlib import Path
from datetime import datetime
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.base import MIMEBase
from email import encoders
import imaplib
import email as emaillib

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# LOGGING
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Path("logs").mkdir(exist_ok=True)
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
    handlers=[
        logging.FileHandler("logs/agent.log"),
        logging.StreamHandler(),
    ],
)
log = logging.getLogger(__name__)

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# SHARED EMAIL BODY (used by all roles)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
SHARED_REPLY = """Hi,

visa:opt-ead
location:TEXAS(can work on w2 also-no need sponsership)
I hope you're doing well. I'm writing to express my interest in any suitable opportunities that match my background and experience.

I have several years of experience working in cloud, DevOps, and production support environments. My work has involved supporting live systems, automating deployments, improving monitoring and reliability, and collaborating closely with cross-functional teams to keep applications stable and performant.

I've attached my resume for your review. I'd appreciate the opportunity to connect and discuss how my skills could be a good fit for your team.

Thank you for your time and consideration.

Best regards,
Lingaraju Modhala
Phone: +1 940 281 5324
Email: rajumodhala777@gmail.com"""

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ROLE CONFIG
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ROLES = [
    {
        "name": "DevOps Engineer",
        "keywords": [
            "devops engineer", "devops lead", "devops",
            "ci/cd engineer", "build and release",
            "devsecops", "release engineer",
        ],
        "resume_secret": "RESUME_DEVOPS_B64",
        "cc_secret": "CC_DEVOPS",
        "reply": SHARED_REPLY,
    },
    {
        "name": "Cloud Engineer",
        "keywords": [
            "cloud engineer", "aws engineer", "azure engineer",
            "gcp engineer", "cloud architect", "cloud infrastructure",
        ],
        "resume_secret": "RESUME_CLOUD_B64",
        "cc_secret": "CC_CLOUD",
        "reply": SHARED_REPLY,
    },
    {
        "name": "Site Reliability Engineer",
        "keywords": [
            "site reliability engineer", "sre",
            "reliability engineer", "production engineer",
        ],
        "resume_secret": "RESUME_SRE_B64",
        "cc_secret": "CC_SRE",
        "reply": SHARED_REPLY,
    },
    {
        "name": "SAP Consultant",
        "keywords": [
            "sap pp", "sap mm", "sap sd", "sap fico", "sap fi",
            "sap co", "sap basis", "sap abap", "sap hana",
            "sap ewm", "sap wm", "sap consultant", "sap analyst",
        ],
        "resume_secret": "RESUME_SAP_B64",
        "cc_secret": "CC_SAP",
        "reply": SHARED_REPLY,
    },
    {
        "name": "Platform Engineer",
        "keywords": [
            "platform engineer", "infrastructure engineer",
            "kubernetes engineer", "linux administrator",
            "systems engineer", "systems administrator",
        ],
        "resume_secret": "RESUME_PLATFORM_B64",
        "cc_secret": "CC_PLATFORM",
        "reply": SHARED_REPLY,
    },
]

DEFAULT_ROLE = {
    "name": "Default",
    "resume_secret": "RESUME_DEFAULT_B64",
    "cc_secret": "CC_DEFAULT",
    "reply": SHARED_REPLY,
}

JOB_KEYWORDS = [
    "hiring", "job opportunity", "urgent requirement", "requirement",
    "opening", "position", "vacancy", "recruitment", "looking for",
    "immediate requirement", "greetings from", "we have an opening",
    "kindly share", "please share your resume", "relevant profile",
    "years of experience", "notice period", "current ctc",
    "expected ctc", "job description", "jd ",
]

STATE_FILE = "logs/processed_ids.json"

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# STATE
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def load_processed():
    if os.path.exists(STATE_FILE):
        with open(STATE_FILE) as f:
            return set(json.load(f))
    return set()

def save_processed(ids):
    with open(STATE_FILE, "w") as f:
        json.dump(list(ids), f)

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# READ EMAILS VIA IMAP
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def fetch_unread_emails(your_email, app_password):
    log.info("ğŸ“¬ Connecting to Gmail via IMAP...")
    mail = imaplib.IMAP4_SSL("imap.gmail.com")
    mail.login(your_email, app_password)
    mail.select("inbox")

    today = datetime.now().strftime("%d-%b-%Y")
    _, msg_ids = mail.search(None, f'(UNSEEN SINCE "{today}")')
    ids = msg_ids[0].split()
    log.info(f"ğŸ“¬ Found {len(ids)} unread emails")

    emails = []
    seen_uids = set()

    for uid in ids[-100:]:
        uid_str = uid.decode()
        if uid_str in seen_uids:
            continue
        seen_uids.add(uid_str)

        try:
            _, msg_data = mail.fetch(uid, "(RFC822)")
            raw = msg_data[0][1]
            msg = emaillib.message_from_bytes(raw)

            message_id = msg.get("Message-ID", uid_str).strip()

            body = ""
            if msg.is_multipart():
                for part in msg.walk():
                    if part.get_content_type() == "text/plain":
                        body = part.get_payload(decode=True).decode("utf-8", errors="ignore")
                        break
            else:
                body = msg.get_payload(decode=True).decode("utf-8", errors="ignore")

            emails.append({
                "uid":        uid_str,
                "message_id": message_id,
                "subject":    msg.get("Subject", ""),
                "sender":     msg.get("From", ""),
                "reply_to":   msg.get("Reply-To", msg.get("From", "")),
                "body":       body[:4000],
            })
        except Exception as e:
            log.error(f"Error reading email {uid}: {e}")

    mail.logout()
    return emails

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# DETECTION
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def is_job_email(email):
    text = (email["subject"] + " " + email["body"]).lower()
    for role in ROLES:
        if any(kw in text for kw in role["keywords"]):
            return True
    return any(kw in text for kw in JOB_KEYWORDS)

def detect_role(email):
    text = (email["subject"] + " " + email["body"]).lower()
    for role in ROLES:
        if any(kw in text for kw in role["keywords"]):
            log.info(f"  ğŸ¯ Matched: {role['name']}")
            return role
    log.info("  ğŸ¯ No specific role â†’ Default")
    return DEFAULT_ROLE

def extract_address(s):
    m = re.search(r"<(.+?)>", s)
    return m.group(1) if m else s.strip()

def extract_company(email):
    addr = extract_address(email["sender"])
    domain = addr.split("@")[-1].split(".")[0].capitalize() if "@" in addr else ""
    generic = ["gmail", "yahoo", "hotmail", "outlook", "rediffmail", "naukri"]
    if domain.lower() not in generic and domain:
        return domain
    return "your organization"

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# GET RESUME FROM SECRET
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Map secret name â†’ b64 filename in repo
RESUME_FILES = {
    "RESUME_DEFAULT_B64":   "resume_default.b64",
    "RESUME_DEVOPS_B64":    "resume_default.b64",
    "RESUME_CLOUD_B64":     "resume_default.b64",
    "RESUME_SRE_B64":       "resume_default.b64",
    "RESUME_SAP_B64":       "resume_default.b64",
    "RESUME_PLATFORM_B64":  "resume_default.b64",
}

def get_resume(role):
    secret_name = role["resume_secret"]

    # 1. Try GitHub Secret (env variable) first
    b64 = os.environ.get(secret_name, "").strip()
    if b64:
        log.info(f"  ğŸ“ Resume from secret: {secret_name}")
        b64 = re.sub(r'\s+', '', b64)
        return base64.b64decode(b64)

    # 2. Fallback to DEFAULT secret
    b64 = os.environ.get("RESUME_DEFAULT_B64", "").strip()
    if b64:
        log.info(f"  ğŸ“ Resume from secret: RESUME_DEFAULT_B64 (fallback)")
        b64 = re.sub(r'\s+', '', b64)
        return base64.b64decode(b64)

    # 3. Fallback to file in repo
    fname = RESUME_FILES.get(secret_name, "resume_default.b64")
    if not Path(fname).exists():
        fname = "resume_default.b64"
    if not Path(fname).exists():
        raise ValueError(
            f"âŒ No resume found! Set GitHub Secret '{secret_name}' or "
            "commit resume_default.b64 to your repository."
        )

    log.info(f"  ğŸ“ Resume from file: {fname}")
    b64 = Path(fname).read_text().strip()
    b64 = re.sub(r'\s+', '', b64)
    return base64.b64decode(b64)

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# SEND EMAIL VIA SMTP
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def send_reply(email, role, your_name, your_email, app_password):
    to_email  = extract_address(email["reply_to"] or email["sender"])
    cc_email  = os.environ.get(role["cc_secret"], "")

    subject = f"Re: {email['subject']}" if not email["subject"].lower().startswith("re:") else email["subject"]
    body    = role["reply"]

    msg = MIMEMultipart()
    msg["From"]    = your_email
    msg["To"]      = to_email
    msg["Subject"] = subject
    if cc_email:
        msg["Cc"] = cc_email

    msg.attach(MIMEText(body, "plain"))

    resume_bytes = get_resume(role)
    part = MIMEBase("application", "octet-stream")
    part.set_payload(resume_bytes)
    encoders.encode_base64(part)
    fname = "Resume_Lingaraju_Modhala.docx"
    part.add_header("Content-Disposition", f'attachment; filename="{fname}"')
    msg.attach(part)

    recipients = [to_email]
    if cc_email:
        recipients.append(cc_email)

    with smtplib.SMTP_SSL("smtp.gmail.com", 465) as server:
        server.login(your_email, app_password)
        server.sendmail(your_email, recipients, msg.as_string())

    log.info(f"  âœ… Sent to: {to_email}")
    if cc_email:
        log.info(f"  ğŸ“‹ CC'd:    {cc_email}")

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# LOG
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def log_sent(email, role):
    csv_path = "logs/sent_log.csv"
    is_new   = not os.path.exists(csv_path)
    with open(csv_path, "a") as f:
        if is_new:
            f.write("timestamp,role,sender,subject,cc\n")
        cc = os.environ.get(role["cc_secret"], "none")
        f.write(f'{datetime.now().isoformat()},"{role["name"]}","{email["sender"]}","{email["subject"]}","{cc}"\n')

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# MAIN
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def main():
    log.info("=" * 55)
    log.info("ğŸ¤– AI Email Agent â€” FREE (Gmail SMTP)")
    log.info(f"â° {datetime.now().isoformat()}")
    log.info("=" * 55)

    your_name    = os.environ.get("YOUR_NAME", "")
    your_email   = os.environ.get("YOUR_EMAIL", "")
    app_password = os.environ.get("GMAIL_APP_PASSWORD", "")

    missing = []
    if not your_name:    missing.append("YOUR_NAME")
    if not your_email:   missing.append("YOUR_EMAIL")
    if not app_password: missing.append("GMAIL_APP_PASSWORD")
    if missing:
        log.error(f"âŒ Missing secrets: {', '.join(missing)}")
        return

    processed = load_processed()
    emails = fetch_unread_emails(your_email, app_password)

    matched = 0
    for email in emails:
        dedup_key = email["message_id"]
        if dedup_key in processed:
            log.info(f"  â­ Already processed: {email['subject'][:60]}")
            continue

        processed.add(dedup_key)

        if not is_job_email(email):
            continue

        log.info(f"\nğŸ¯ JOB EMAIL: {email['subject']}")
        log.info(f"   From: {email['sender']}")
        matched += 1

        try:
            role = detect_role(email)
            send_reply(email, role, your_name, your_email, app_password)
            log_sent(email, role)
        except Exception as e:
            log.error(f"âŒ Error: {e}", exc_info=True)

    save_processed(processed)
    log.info(f"\nâœ… Done â€” Replied to {matched} job emails out of {len(emails)} scanned")
    log.info("ğŸ’° Cost: â‚¹0.00")

if __name__ == "__main__":
    main()
